#include "main.h"
#include "images/startscreen.h"
#include "images/goal.h"
#include "images/winscreen.h"
#include "images/losescreen.h"
#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  DRAWSTART,
  PLAY,
  DRAWPLAY,
  PLAYBALL,
  WIN,
  DRAWWIN,
  LOSE,
  DRAWLOSE,

};
struct Ball myBall = {120, 60, 5, 5, 5, RED};
int goals=0;
int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT= (MODE3 | BG2_ENABLE);
  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  enum gba_state state = START;

  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw

    switch (state) {
      case START:
       waitForVBlank();
        drawFullScreenImageDMA(startscreen); //Draw picture on screen
        state = DRAWSTART;
        break;
      case DRAWSTART:
        waitForVBlank();
        drawString(80, 70, "Press ENTER to start", WHITE); //Draw text
        waitForVBlank();
        drawString(40,70, "AARON LEAGUE SOCCER", CYAN);
        if (KEY_DOWN(BUTTON_START, currentButtons) && !KEY_DOWN(BUTTON_START, previousButtons)) {
            state = DRAWPLAY;
            break;
        }
        break;
      case DRAWPLAY:
        waitForVBlank();
        fillScreenDMA(GREEN);//the screen will be green
        waitForVBlank();
        for (int j=0; j<240 ;j++){
          setPixel(130,j,RED);
        }
        myBall.x = 60;
        myBall.y = 120;
        drawRectDMA(myBall.x,myBall.y,5,5,BLUE);
        state = PLAY;
        
        break;
      case PLAY:
        waitForVBlank();
        drawImageDMA(130,90, 40, 30, goal); //Draw the goal post on screen;
        char goalString[10]; // Buffer to hold the goal count as a string
        sprintf(goalString, "Goals: %d", goals);
        drawString(150,0, goalString, WHITE); //Goal counter
        state=PLAYBALL;
        break;
      case PLAYBALL:
        if (KEY_DOWN(BUTTON_SELECT, currentButtons) && !KEY_DOWN(BUTTON_SELECT, previousButtons)) {
            state = START;
            goals=0;
            break;
         } 
       // drawRectDMA(myBall.x,myBall.y,5,5,BLUE);
        if (KEY_DOWN(BUTTON_UP, currentButtons)) {
          // Move the ball up
          drawRectDMA(myBall.x,myBall.y,5,5,GREEN);
          waitForVBlank();
          waitForVBlank();
           if (myBall.x+myBall.dx>130){
            if (myBall.y>90 && myBall.y<130){
              goals++;
              state= DRAWPLAY;
              break;
            } else {
              state=LOSE;
            }
           }
           myBall.x -= myBall.dx;
          }
        if (KEY_DOWN(BUTTON_DOWN, currentButtons)) {
          // Move the ball down
          drawRectDMA(myBall.x,myBall.y,5,5,GREEN);
            if (myBall.x+myBall.dx>130){
            if (myBall.y>90 && myBall.y<130){
              goals++;
              state= DRAWPLAY;
              break;
            } else {
              state=LOSE;
            }
           }
           myBall.x += myBall.dx;
          }
        if (KEY_DOWN(BUTTON_RIGHT, currentButtons)) {
          // Move the ball right
          drawRectDMA(myBall.x,myBall.y,5,5,GREEN);
           if (myBall.x+myBall.dx>130){
            if (myBall.y>90 && myBall.y<130){
              goals++;
              state= DRAWPLAY;
              break;
            } else {
              state=LOSE;
            }
           }
          myBall.y += myBall.dy;
          }
        if (KEY_DOWN(BUTTON_LEFT, currentButtons)) {
          // Move the ball left
          drawRectDMA(myBall.x,myBall.y,5,5,GREEN);
            if (myBall.x+myBall.dx>130){
            if (myBall.y>90 && myBall.y<130){
              goals++;
              state= DRAWPLAY;
              break;
            } else {
              state=LOSE;
            }
           }
           myBall.y -= myBall.dy;
          }
        drawRectDMA(myBall.x,myBall.y,5,5,BLUE);
        waitForVBlank();
        waitForVBlank();
        if (goals==3){
          state=WIN;
          break;
        }
        if (myBall.x<0 || myBall.x>160){
          state=LOSE;
        }
        if (myBall.y<0 ||myBall.y>240){
          state=LOSE;
        }

        break;
      case WIN:
        waitForVBlank();
        goals=0;
        drawFullScreenImageDMA(winscreen);
        state=DRAWWIN;
        break;
      case DRAWWIN:
         if (KEY_DOWN(BUTTON_SELECT, currentButtons) && !KEY_DOWN(BUTTON_SELECT, previousButtons)) {
            state = START;
            break;
         }
        break;
      case LOSE:
        waitForVBlank();
        goals=0;
        drawFullScreenImageDMA(losescreen);
        state=DRAWLOSE;
        break;
      case DRAWLOSE:
        waitForVBlank();
        drawString(120, 20, "Better luck next time!" , YELLOW); 
        waitForVBlank();
        drawString(140,20,"Press Back to return!", YELLOW);
        if (KEY_DOWN(BUTTON_SELECT, currentButtons) && !KEY_DOWN(BUTTON_SELECT, previousButtons)) {
            
            state = START;
            break;
        }
        break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  
  }
  return 0;
}
